{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "DWH-NonProd-ADF"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/ProcessSourceBlob_opscontract_spl')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "LookupStagingOpsContract",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": "SELECT count(*) Total_Error\n  FROM [staging].[OPS_Contract]\n  WHERE [Validation_Error] IS NOT NULL"
							},
							"dataset": {
								"referenceName": "SQLstagingopscontract_ds",
								"type": "DatasetReference"
							}
						}
					},
					{
						"name": "If Condition1",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "LookupStagingOpsContract",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@greater(activity('LookupStagingOpsContract').output.firstRow.TOTAL_ERROR,0)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "LoadStagingDBtoRelationDB_opscontract_df",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "LoadStagingDBtoRelationDB_opscontract_df",
											"type": "DataFlowReference",
											"parameters": {
												"ProcessName": {
													"value": "'@{pipeline().parameters.ProcessName}'",
													"type": "Expression"
												},
												"FileName": {
													"value": "'@{pipeline().parameters.FileName}'",
													"type": "Expression"
												},
												"Etl_Utc_Tag": {
													"value": "'@{pipeline().parameters.Etl_Utc_Tag}'",
													"type": "Expression"
												}
											}
										},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										}
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "UpdateSourceRegisterTableAbort",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": "[[log].[UpdateSourceRegisterFailedAbort]",
										"storedProcedureParameters": {
											"EtlUtcTag": {
												"value": {
													"value": "@pipeline().parameters.Etl_Utc_Tag",
													"type": "Expression"
												},
												"type": "String"
											},
											"FileName": {
												"value": {
													"value": "@pipeline().parameters.OriginalBlobName",
													"type": "Expression"
												},
												"type": "String"
											}
										}
									},
									"linkedServiceName": {
										"referenceName": "SQLdbConnection",
										"type": "LinkedServiceReference"
									}
								}
							]
						}
					}
				],
				"parameters": {
					"ProcessName": {
						"type": "string"
					},
					"FileName": {
						"type": "string"
					},
					"Etl_Utc_Tag": {
						"type": "string"
					},
					"OriginalBlobName": {
						"type": "string"
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/LoadStagingDBtoRelationDB_opscontract_df')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ProcessSourceBlob_opsoperation_spl')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "LookupStagingOpsOperation",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": "SELECT count(*) Total_Error\n  FROM [staging].[OPS_Operation]\n  WHERE [Validation_Error] IS NOT NULL"
							},
							"dataset": {
								"referenceName": "SQLstagingopsoperation_ds",
								"type": "DatasetReference"
							}
						}
					},
					{
						"name": "ProcessStagingToRelational",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "LookupStagingOpsOperation",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@greater(activity('LookupStagingOpsOperation').output.firstRow.TOTAL_ERROR,0)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "LoadStagingDBtoRelationDB_opsoperation_df",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "LoadStagingDBtoRelationDB_opsoperation_df",
											"type": "DataFlowReference",
											"parameters": {
												"ProcessName": {
													"value": "'@{pipeline().parameters.ProcessName}'",
													"type": "Expression"
												},
												"FileName": {
													"value": "'@{pipeline().parameters.FileName}'",
													"type": "Expression"
												},
												"Etl_Utc_Tag": {
													"value": "'@{pipeline().parameters.Etl_Utc_Tag}'",
													"type": "Expression"
												}
											}
										},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										}
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "UpdateSourceRegisterTableAbort",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": "[[log].[UpdateSourceRegisterFailedAbort]",
										"storedProcedureParameters": {
											"EtlUtcTag": {
												"value": {
													"value": "@pipeline().parameters.Etl_Utc_Tag",
													"type": "Expression"
												},
												"type": "String"
											},
											"FileName": {
												"value": {
													"value": "@pipeline().parameters.OriginalBlobName",
													"type": "Expression"
												},
												"type": "String"
											}
										}
									},
									"linkedServiceName": {
										"referenceName": "SQLdbConnection",
										"type": "LinkedServiceReference"
									}
								}
							]
						}
					}
				],
				"parameters": {
					"ProcessName": {
						"type": "string"
					},
					"FileName": {
						"type": "string"
					},
					"Etl_Utc_Tag": {
						"type": "string"
					},
					"OriginalBlobName": {
						"type": "string"
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/LoadStagingDBtoRelationDB_opsoperation_df')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadStagingDBtoRelationDB_opscontract_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SQLstagingopscontract_ds",
								"type": "DatasetReference"
							},
							"name": "StagingDB"
						},
						{
							"dataset": {
								"referenceName": "SQLrelationopscontract_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalContract"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLrelationopscontract_ds",
								"type": "DatasetReference"
							},
							"name": "UpserttRow"
						}
					],
					"transformations": [
						{
							"name": "SelectStagingData"
						},
						{
							"name": "AddAuditColumns"
						},
						{
							"name": "GenerateRelationalChecksum"
						},
						{
							"name": "SelectRelationalData"
						},
						{
							"name": "GenerateStagingChecksum"
						},
						{
							"name": "CompareKeys"
						},
						{
							"name": "UnionNewAndExisting"
						},
						{
							"name": "SelectNewRecordData"
						},
						{
							"name": "AlterRowUpsert"
						},
						{
							"name": "ConvertDatesAndNumber"
						},
						{
							"name": "NewAndExistingContract"
						},
						{
							"name": "ChangedAddAuditData"
						},
						{
							"name": "SelectChangeRecord"
						}
					],
					"script": "parameters{\n\tProcessName as string,\n\tFileName as string,\n\tEtl_Utc_Tag as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tContract_ID as string,\n\t\tReporting_Period as string,\n\t\tExecution_Date as string,\n\t\tTermination_Date as string,\n\t\tCompany_Name as string,\n\t\tContract_Value as string,\n\t\tContract_Currency as string,\n\t\tContract_Type_Code as string,\n\t\tExecuted_By_Entity1 as string,\n\t\tExecuted_By_Entity2 as string,\n\t\tExecuted_By_Entity3 as string,\n\t\tValidation_Error as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingDB\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tContract_ID as integer,\n\t\tReporting_Period as date,\n\t\tExecution_Date as date,\n\t\tTermination_Date as date,\n\t\tCompany_Name as string,\n\t\tContract_Value as decimal(19,4),\n\t\tContract_Currency as string,\n\t\tContract_Type as string,\n\t\tExecuted_By_Entity1 as string,\n\t\tExecuted_By_Entity2 as string,\n\t\tExecuted_By_Entity3 as string,\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> RelationalContract\nGenerateStagingChecksum select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tContract_ID,\n\t\tReporting_Period,\n\t\tExecution_Date,\n\t\tTermination_Date,\n\t\tCompany_Name,\n\t\tContract_Value,\n\t\tContract_Currency,\n\t\tContract_Type_Code,\n\t\tExecuted_By_Entity1,\n\t\tExecuted_By_Entity2,\n\t\tExecuted_By_Entity3,\n\t\tStagingChecksum\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> SelectStagingData\nSelectNewRecordData derive(insert_datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tprocess_name = concatWS('_',$ProcessName,$FileName)) ~> AddAuditColumns\nRelationalContract derive(RelationalChecksum = sha2(256, Reporting_Period,Execution_Date,Termination_Date,Company_Name,Contract_Value,Contract_Currency,Contract_Type,Executed_By_Entity1,Executed_By_Entity2,Executed_By_Entity3)) ~> GenerateRelationalChecksum\nGenerateRelationalChecksum select(mapColumn(\n\t\tRelation_Asset_ID = Asset_ID,\n\t\tRelation_Fund_ID = Fund_ID,\n\t\tRelation_Contract_ID = Contract_ID,\n\t\tRelation_Reporting_Period = Reporting_Period,\n\t\tRelation_Execution_Date = Execution_Date,\n\t\tRelation_Termination_Date = Termination_Date,\n\t\tRelation_Company_Name = Company_Name,\n\t\tRelation_Contract_Value = Contract_Value,\n\t\tRelation_Contract_Currency = Contract_Currency,\n\t\tRelation_Contract_Type = Contract_Type,\n\t\tRelation_Executed_By_Entity1 = Executed_By_Entity1,\n\t\tRelation_Executed_By_Entity2 = Executed_By_Entity2,\n\t\tRelation_Executed_By_Entity3 = Executed_By_Entity3,\n\t\tRelation_Insert_Datetime = Insert_Datetime,\n\t\tRelation_Update_Datetime = Update_Datetime,\n\t\tRelation_Process_Name = Process_Name,\n\t\tRelation_RelationalChecksum = RelationalChecksum\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectRelationalData\nConvertDatesAndNumber derive(StagingChecksum = sha2(256, Reporting_Period,Execution_Date,Termination_Date,Company_Name,Contract_Value,Contract_Currency,Contract_Type_Code,Executed_By_Entity1,Executed_By_Entity2,Executed_By_Entity3)) ~> GenerateStagingChecksum\nSelectStagingData, SelectRelationalData lookup(Asset_ID == Relation_Asset_ID\n\t&& Fund_ID == Relation_Fund_ID\n\t&& Contract_ID == Relation_Contract_ID,\n\tmultiple: true,\n\tbroadcast: 'none')~> CompareKeys\nAddAuditColumns, SelectChangeRecord union(byName: true)~> UnionNewAndExisting\nNewAndExistingContract@NewContract select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tContract_ID,\n\t\tReporting_Period,\n\t\tExecution_Date,\n\t\tTermination_Date,\n\t\tCompany_Name,\n\t\tContract_Value,\n\t\tContract_Currency,\n\t\tContract_Type_Code,\n\t\tExecuted_By_Entity1,\n\t\tExecuted_By_Entity2,\n\t\tExecuted_By_Entity3\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectNewRecordData\nUnionNewAndExisting alterRow(upsertIf(true())) ~> AlterRowUpsert\nStagingDB derive(Reporting_Period = toDate(Reporting_Period, \"dd/MM/yyyy\"),\n\t\tContract_ID = toInteger(Contract_ID),\n\t\tExecution_Date = toDate(Execution_Date, \"dd/MM/yyyy\"),\n\t\tTermination_Date = toDate(Termination_Date, \"dd/MM/yyyy\"),\n\t\tContract_Value = toDecimal(Contract_Value, 19, 4, \"###,###.##\")) ~> ConvertDatesAndNumber\nCompareKeys split(isNull(Relation_RelationalChecksum),\n\tStagingChecksum != Relation_RelationalChecksum || Contract_Value != Relation_Contract_Value,\n\tdisjoint: false) ~> NewAndExistingContract@(NewContract, ChangedContract, ExistingNoChange)\nNewAndExistingContract@ChangedContract derive(update_datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tprocess_name = concatWS('_',$ProcessName,$FileName)) ~> ChangedAddAuditData\nChangedAddAuditData select(mapColumn(\n\t\tAsset_ID = Relation_Asset_ID,\n\t\tFund_ID = Relation_Fund_ID,\n\t\tContract_ID = Relation_Contract_ID,\n\t\tReporting_Period,\n\t\tExecution_Date,\n\t\tTermination_Date,\n\t\tCompany_Name,\n\t\tContract_Value,\n\t\tContract_Currency,\n\t\tContract_Type_Code,\n\t\tExecuted_By_Entity1,\n\t\tExecuted_By_Entity2,\n\t\tExecuted_By_Entity3,\n\t\tinsert_datetime = Relation_Insert_Datetime,\n\t\tupdate_datetime,\n\t\tprocess_name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectChangeRecord\nAlterRowUpsert sink(input(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tContract_ID as integer,\n\t\tReporting_Period as date,\n\t\tExecution_Date as date,\n\t\tTermination_Date as date,\n\t\tCompany_Name as string,\n\t\tContract_Value as decimal(19,4),\n\t\tContract_Currency as string,\n\t\tContract_Type as string,\n\t\tExecuted_By_Entity1 as string,\n\t\tExecuted_By_Entity2 as string,\n\t\tExecuted_By_Entity3 as string,\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:true,\n\tkeys:['Asset_ID','Fund_ID','Contract_ID'],\n\tformat: 'table',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tContract_ID,\n\t\tReporting_Period,\n\t\tExecution_Date,\n\t\tTermination_Date,\n\t\tCompany_Name,\n\t\tContract_Value,\n\t\tContract_Currency,\n\t\tContract_Type = Contract_Type_Code,\n\t\tExecuted_By_Entity1,\n\t\tExecuted_By_Entity2,\n\t\tExecuted_By_Entity3,\n\t\tInsert_Datetime = insert_datetime,\n\t\tUpdate_Datetime = update_datetime,\n\t\tProcess_Name = process_name\n\t)) ~> UpserttRow"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadStagingDBtoRelationDB_opsoperation_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SQLstagingopsoperation_ds",
								"type": "DatasetReference"
							},
							"name": "StagingDB"
						},
						{
							"dataset": {
								"referenceName": "SQLrelationopsoperation",
								"type": "DatasetReference"
							},
							"name": "RelationalOperation"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLrelationopsoperation",
								"type": "DatasetReference"
							},
							"name": "UpserttRow"
						}
					],
					"transformations": [
						{
							"name": "SelectStagingData"
						},
						{
							"name": "AddAuditColumns"
						},
						{
							"name": "GenerateRelationalChecksum"
						},
						{
							"name": "SelectRelationalData"
						},
						{
							"name": "GenerateStagingChecksum"
						},
						{
							"name": "CompareKeys"
						},
						{
							"name": "UnionNewAndExisting"
						},
						{
							"name": "SelectNewRecordData"
						},
						{
							"name": "AlterRowUpsert"
						},
						{
							"name": "ConvertDatesAndIdAndNumbers"
						},
						{
							"name": "NewAndExistingOperation"
						},
						{
							"name": "ChangedAddAuditData"
						},
						{
							"name": "SelectChangeRecord"
						}
					],
					"script": "parameters{\n\tProcessName as string,\n\tFileName as string,\n\tEtl_Utc_Tag as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tOperation_Id as string,\n\t\tReporting_Period as string,\n\t\tOperation_Type_Code as string,\n\t\tArea_Treated as string,\n\t\tTreatment_Cost as string,\n\t\tUnit_Cost as string,\n\t\tLast_Age_Class_Date as string,\n\t\tSpecies_Survived as string,\n\t\tLast_Age_Class_Survival_Rate as string,\n\t\tBudget_Area_Treated as string,\n\t\tBudget_Treatment_Cost as string,\n\t\tBudget_Unit_Cost as string,\n\t\tValidation_Error as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingDB\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tOperation_Id as integer,\n\t\tReporting_Period as date,\n\t\tOperation_Type_Code as string,\n\t\tArea_Treated as decimal(19,4),\n\t\tTreatment_Cost as decimal(19,4),\n\t\tUnit_Cost as decimal(19,4),\n\t\tLast_Age_Class_Date as date,\n\t\tSpecies_Survived as string,\n\t\tLast_Age_Class_Survival_Rate as decimal(5,2),\n\t\tBudget_Area_Treated as decimal(19,4),\n\t\tBudget_Treatment_Cost as decimal(19,4),\n\t\tBudget_Unit_Cost as decimal(19,4),\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> RelationalOperation\nGenerateStagingChecksum select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tOperation_Id,\n\t\tReporting_Period,\n\t\tOperation_Type_Code,\n\t\tArea_Treated,\n\t\tTreatment_Cost,\n\t\tUnit_Cost,\n\t\tLast_Age_Class_Date,\n\t\tSpecies_Survived,\n\t\tLast_Age_Class_Survival_Rate,\n\t\tBudget_Area_Treated,\n\t\tBudget_Treatment_Cost,\n\t\tBudget_Unit_Cost,\n\t\tStagingChecksum\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> SelectStagingData\nSelectNewRecordData derive(insert_datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tprocess_name = concatWS('_',$ProcessName,$FileName)) ~> AddAuditColumns\nRelationalOperation derive(RelationalChecksum = sha2(256, Reporting_Period,Operation_Type_Code,Area_Treated,Treatment_Cost,Unit_Cost,Last_Age_Class_Date,Species_Survived,Last_Age_Class_Survival_Rate,Budget_Area_Treated,Budget_Treatment_Cost,Budget_Unit_Cost)) ~> GenerateRelationalChecksum\nGenerateRelationalChecksum select(mapColumn(\n\t\tRelation_Asset_ID = Asset_ID,\n\t\tRelation_Fund_ID = Fund_ID,\n\t\tRelation_Operation_Id = Operation_Id,\n\t\tRelation_Reporting_Period = Reporting_Period,\n\t\tRelation_Operation_Type_Code = Operation_Type_Code,\n\t\tRelation_Area_Treated = Area_Treated,\n\t\tRelation_Treatment_Cost = Treatment_Cost,\n\t\tRelation_Unit_Cost = Unit_Cost,\n\t\tRelation_Last_Age_Class_Date = Last_Age_Class_Date,\n\t\tRelation_Species_Survived = Species_Survived,\n\t\tRelation_Last_Age_Class_Survival_Rate = Last_Age_Class_Survival_Rate,\n\t\tRelation_Budget_Area_Treated = Budget_Area_Treated,\n\t\tRelation_Budget_Treatment_Cost = Budget_Treatment_Cost,\n\t\tRelation_Budget_Unit_Cost = Budget_Unit_Cost,\n\t\tRelation_Insert_Datetime = Insert_Datetime,\n\t\tRelation_Update_Datetime = Update_Datetime,\n\t\tRelation_Process_Name = Process_Name,\n\t\tRelation_RelationalChecksum = RelationalChecksum\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectRelationalData\nConvertDatesAndIdAndNumbers derive(StagingChecksum = sha2(256, Reporting_Period,Operation_Type_Code,Area_Treated,Treatment_Cost,Unit_Cost,Last_Age_Class_Date,Species_Survived,Last_Age_Class_Survival_Rate,Budget_Area_Treated,Budget_Treatment_Cost,Budget_Unit_Cost)) ~> GenerateStagingChecksum\nSelectStagingData, SelectRelationalData lookup(Asset_ID == Relation_Asset_ID\n\t&& Fund_ID == Relation_Fund_ID\n\t&& Operation_Id == Relation_Operation_Id,\n\tmultiple: true,\n\tbroadcast: 'none')~> CompareKeys\nAddAuditColumns, SelectChangeRecord union(byName: true)~> UnionNewAndExisting\nNewAndExistingOperation@NewOperation select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tOperation_Id,\n\t\tReporting_Period,\n\t\tOperation_Type_Code,\n\t\tArea_Treated,\n\t\tTreatment_Cost,\n\t\tUnit_Cost,\n\t\tLast_Age_Class_Date,\n\t\tSpecies_Survived,\n\t\tLast_Age_Class_Survival_Rate,\n\t\tBudget_Area_Treated,\n\t\tBudget_Treatment_Cost,\n\t\tBudget_Unit_Cost\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectNewRecordData\nUnionNewAndExisting alterRow(upsertIf(true())) ~> AlterRowUpsert\nStagingDB derive(Reporting_Period = toDate(Reporting_Period, \"dd/MM/yyyy\"),\n\t\tLast_Age_Class_Date = toDate(Last_Age_Class_Date, \"dd/MM/yyyy\"),\n\t\tOperation_Id = toInteger(Operation_Id),\n\t\tArea_Treated = toDecimal(Area_Treated, 19, 4, \"###,###.####\"),\n\t\tTreatment_Cost = toDecimal(Treatment_Cost, 19, 4, \"###,###.####\"),\n\t\tUnit_Cost = toDecimal(Unit_Cost, 19, 4, \"###,###.####\"),\n\t\tLast_Age_Class_Survival_Rate = toDecimal(Last_Age_Class_Survival_Rate, 5, 2, \"###.##\"),\n\t\tBudget_Area_Treated = toDecimal(Budget_Area_Treated, 19, 4, \"###,###.####\"),\n\t\tBudget_Treatment_Cost = toDecimal(Budget_Treatment_Cost, 19, 4, \"###,###.####\"),\n\t\tBudget_Unit_Cost = toDecimal(Budget_Unit_Cost, 19, 4, \"###,###.####\")) ~> ConvertDatesAndIdAndNumbers\nCompareKeys split(isNull(Relation_RelationalChecksum),\n\tStagingChecksum != Relation_RelationalChecksum || \r\nArea_Treated != Relation_Area_Treated || \r\nTreatment_Cost != Relation_Treatment_Cost || \r\nUnit_Cost != Relation_Unit_Cost || \r\nLast_Age_Class_Survival_Rate != Relation_Last_Age_Class_Survival_Rate || \r\nBudget_Area_Treated != Relation_Budget_Area_Treated || \r\nBudget_Treatment_Cost != Relation_Budget_Treatment_Cost|| \r\nBudget_Unit_Cost != Relation_Budget_Unit_Cost,\n\tdisjoint: false) ~> NewAndExistingOperation@(NewOperation, ChangedOperation, ExistingNoChange)\nNewAndExistingOperation@ChangedOperation derive(update_datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tprocess_name = concatWS('_',$ProcessName,$FileName)) ~> ChangedAddAuditData\nChangedAddAuditData select(mapColumn(\n\t\tAsset_ID = Relation_Asset_ID,\n\t\tFund_ID = Relation_Fund_ID,\n\t\tOperation_Id = Relation_Operation_Id,\n\t\tReporting_Period,\n\t\tOperation_Type_Code,\n\t\tArea_Treated,\n\t\tTreatment_Cost,\n\t\tUnit_Cost,\n\t\tLast_Age_Class_Date,\n\t\tSpecies_Survived,\n\t\tLast_Age_Class_Survival_Rate,\n\t\tBudget_Area_Treated,\n\t\tBudget_Treatment_Cost,\n\t\tBudget_Unit_Cost,\n\t\tinsert_datetime = Relation_Insert_Datetime,\n\t\tupdate_datetime,\n\t\tprocess_name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectChangeRecord\nAlterRowUpsert sink(input(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tOperation_Id as integer,\n\t\tReporting_Period as date,\n\t\tOperation_Type_Code as string,\n\t\tArea_Treated as decimal(19,4),\n\t\tTreatment_Cost as decimal(19,4),\n\t\tUnit_Cost as decimal(19,4),\n\t\tLast_Age_Class_Date as date,\n\t\tSpecies_Survived as string,\n\t\tLast_Age_Class_Survival_Rate as decimal(5,2),\n\t\tBudget_Area_Treated as decimal(19,4),\n\t\tBudget_Treatment_Cost as decimal(19,4),\n\t\tBudget_Unit_Cost as decimal(19,4),\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:true,\n\tkeys:['Asset_ID','Fund_ID','Operation_Id'],\n\tformat: 'table',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tOperation_Id,\n\t\tReporting_Period,\n\t\tOperation_Type_Code,\n\t\tArea_Treated,\n\t\tTreatment_Cost,\n\t\tUnit_Cost,\n\t\tLast_Age_Class_Date,\n\t\tSpecies_Survived,\n\t\tLast_Age_Class_Survival_Rate,\n\t\tBudget_Area_Treated,\n\t\tBudget_Treatment_Cost,\n\t\tBudget_Unit_Cost,\n\t\tInsert_Datetime = insert_datetime,\n\t\tUpdate_Datetime = update_datetime,\n\t\tProcess_Name = process_name\n\t)) ~> UpserttRow"
				}
			},
			"dependsOn": []
		}
	]
}